import dts from "bun-plugin-dts";
import { writeFileSync, readFileSync, readdirSync, existsSync } from "fs";
import { resolve, relative } from "path";
import { execSync } from "child_process";
import type { BuildConfig } from "bun";
import { join, relative } from "path";

const baseDir = "./src";

generateIndexes(baseDir, [
  { dir: "types", isTypes: true },
  { dir: "classes" },
]);

// Get Git commit count
const count = parseInt(
  execSync("git rev-list --count HEAD").toString().trim(),
  10
);

// Compute MAJOR.MINOR.PATCH
const MAJOR = Math.floor(count / 10000);
const MINOR = Math.floor((count / 100) % 100);
const PATCH = count % 100;
const version = `${MAJOR}.${MINOR}.${PATCH}`;

// Update package.json
const pkgPath = "./package.json";
const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
pkg.version = version;
writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + "\n");

const minify = true;
const formats: Array<BuildConfig["format"]> = ["cjs", "esm"];

for (const format of formats) {
  Bun.build({
    entrypoints: ["./src/index.ts"],
    outdir: `./dist/`,
    minify: minify,
    target: "browser",
    format: format,
    plugins: [dts()],
    splitting: true,
    naming: {
      entry: `[name].${format}.js`,
      chunk: "[name]-[hash].js",
      asset: "[name]-[hash][ext]",
    },
  }).catch((err) => {
    console.error(err);
    process.exit(1);
  });
}

type IndexConfig = {
  dir: string;
  isTypes?: boolean;
  subDirs?: string[];
};

function generateIndexes(baseDir: string, configs: IndexConfig[]) {
  function walk(dir: string): string[] {
    let results: string[] = [];
    for (const file of readdirSync(dir, { withFileTypes: true })) {
      const fullPath = join(dir, file.name);
      if (file.isDirectory()) {
        results = results.concat(walk(fullPath));
      } else {
        results.push(fullPath);
      }
    }
    return results;
  }

  let baseExports: string[] = [];

  for (const { dir, isTypes = false, subDirs = [] } of configs) {
    const absDir = join(baseDir, dir);
    const files = walk(absDir);
    const imports = files
      .map((file: string) => {
        if (file.endsWith("index.ts")) return;
        if (file.endsWith(".ts")) {
          let relPath =
            "./" +
            relative(absDir, file).replace(/\\/g, "/").replace(/\.ts$/, "");
          return `export ${isTypes ? "type " : ""}* from "${relPath}";`;
        }
      })
      .filter(Boolean)
      .join("\n");

    const indexFileName = `index.ts`;
    writeFileSync(join(absDir, indexFileName), `/**
 * Automatically generated by the bundler. DO NOT EDIT!
 */\n
${imports}`);

    // Add export from this index to baseDir index
    const relPathToBase =
      "./" +
      relative(baseDir, join(absDir, indexFileName))
        .replace(/\\/g, "/")
        .replace(/\.ts$/, "");
    baseExports.push(
      `export ${isTypes ? "type " : ""}* from "${relPathToBase}";`
    );

    if (subDirs.length > 0) {
      let exports: string[] = [];
      subDirs.forEach((subDir) => {
        const indexPath = join(baseDir, subDir, "index.ts");
        if (existsSync(indexPath)) {
          const relPath =
            "./" +
            relative(absDir, indexPath)
              .replace(/\\/g, "/")
              .replace(/\.ts$/, "");
          exports.push(`export ${isTypes ? "type " : ""}* from "${relPath}";`);
        }
      });
      if (exports.length > 0) {
        writeFileSync(
          join(absDir, "index.ts"),
          `/**
 * Automatically generated by the bundler. DO NOT EDIT!
 */\n
${exports.join("\n")}`
        );
      }
    }
  }

  // Write index.ts in baseDir
  if (baseExports.length > 0) {
    writeFileSync(join(baseDir, "index.ts"), `/**
 * Automatically generated by the bundler. DO NOT EDIT!
 */\n
${baseExports.join("\n")}`);
  }
}
